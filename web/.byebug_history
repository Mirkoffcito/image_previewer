c
src
sc
ImagePreviewer.settings[:root]
"#{ImagePreviewer.settings[:root]}#{src}"
c
full_path.sub(/\A#{Regexp.escape(settings[:root])}/, "")
full_path.sub(/\A#{Regexp.escape(settings[:root])}/, "").sub("/public", "")
full_path.sub(/\A#{Regexp.escape(settings[:root])}/, "")
full_path.sub(/\A#{Regexp.escape(settings[:root])}/ + "/public", "")
full_path.sub(/\A#{Regexp.escape(settings[:root])}/, "")
full_path.sub(/\A#{Regexp.escape(settings[:root]}), "")
full_path.sub(/\A#{Regexp.escape(settings[:root])}, "")
full_path.sub(/\A#{Regexp.escape(settings[:root]), "")
full_path.sub(/\A#{Regexp.escape(settings[:root])}, "")
full_path.sub(/\A#{Regexp.escape("#{settings[:root]}", "")
full_path.sub(/\A#{Regexp.escape("#{settings[:root]}public", "")
full_path.sub(/\A#{Regexp.escape("#{settings[:root]}/public", "")
full_path.sub(/\A#{Regexp.escape("#{settings[:root])}/public", "")
full_path.sub(/\A#{Regexp.escape(settings[:root])}/public, "")
full_path.sub(/\A#{Regexp.escape(settings[:root])}/, "")
full_path
c
JSON.parse(decoded)
decoded
c
out_path
c
output_path(options.values.first, 'pdf')
options
input
c
full_path
c
full_path
c
image.extract_band(0, n: 3)
image.cast(:uchar)
image = image.colourspace(:srgb)
image.format
image
c
image.has_alpha?
image.has_alpha
image.bands
image.format
c
[255] * 3
image.bands - 1
image.bands -1
image.bands
image.has_alpha?
image
c
convert(tempfiles_data.first[:tempfile].path)
convert(tempfiles_data.first[:tempfile].path, tempfiles_data.first[:filename])
tempfiles_data.first[:filename]
convert(tempfiles_data.first[:tempfile].path, tempfiles_data.first[:filename])
convert(tempfiles_data.first[:tempfile].path)
out_paths
c
tempfiles_data.first[:filename]
tempfiles_data.first[:tempfile].path
tempfiles_data.first[:tempfile]
tempfiles_data[:tempfile]
tempfiles_data
c
upload.map { |k, v| { filename: v["filename"] } }
upload.map { |k, v| v["filename"] }
upload.map { |k, v| puts k }
upload.map { |k, v| puts v }
c
upload.map.with_index(0) { |(k,v), i| puts "key #{v} index #{i}" }
upload.map.with_index(0) { |(k,v), i| puts "key #{k} index #{i}" }
upload
c
upload.map.with_index(0) { |u, i| puts i }
upload["0"]["tempfile"]
upload["0"]
upload
c
upload["1"]
upload[""]
upload["0"]
upload[0]
upload
upload.map.with_index(0) { |u, i| puts i }
upload.map.with_index(0)
upload.map.with_index
upload
tempfiles_data
c
params
tempfiles_data
c
params["files"][0]
params["files"]
c
upload[0].map.with_index { |u, i| puts i }
upload["0"].map.with_index { |u, i| puts i }
upload
upload.map.with_index { |u, i| puts i }
upload
c
tempfiles_data
c
upload.first
upload
tempfiles_data
c
params
c
out_path
c
out_path
c
out_path
c
params
c
params
c
params
c
params
c
out_path
c
out_path
c
@format
format
c
@format
params["scale"]
params["cale"]
params["format"]
params
c
format
c
out_path
c
out_path
c
out_path
c
rel_path
c
params["files"].map { |h| puts h.keys }
params
params["files"].map { |h| puts h.keys.first }
params["files"].map { |k,v| puts k }
params["files"]
params
c
rel_path
c
params
c
params
c
params["files"]c
params["files"]
params
c
params
c
params
c
params
c
params
c
params
c
params
c
tempfile
c
params
c
params
c
filename
params["file"]["0"]
params["file"]
upload
c
tempfile = params["file"]["0"]["tempfile"]
params["file"]["0"]
params["file"]
upload
params
c
upload
c
params
upload
tempfile
c
params["file"]["0"]["tempfile"]
params["file"]["0"]
c
params["file"]["0"]
params
c
params["file"]["filename"]
params["file"]
params
c
params
c
full_path
c
full_path
c
options[:filename]
File.basename(options[:filename], ".*")
Filename.basename(options[:filename], ".*")
options[:filename]
options
input
options
c
options
out
c
src
c
src
src.to_s
src.to_sd
src
c
File.exist?(img)
img
c
thumbnail_image(src, size: size)
c
thumbnail_image(src, size: size)
src
c
thumbnail_image(src, size: size)
thumbnail_image
src
c
cc
c
thumb_path.sub(%r{\A#{Regexp.escape(public_root)}}, "")
c
thumb_path.sub(%r{\A#{Regexp.escape(public_root)}/public}, "")
c
thumb_path
c
public_root
